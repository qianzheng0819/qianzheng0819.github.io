---
layout: post
title:  "Glide之缓存和内存管理"
date:   2021-06-02 10:48:00 +0800
tags:   开源库
description:
---

前言
--------------
本篇文章从四个问题来分析glide的缓存和内存管理

* 图片请求的三级缓存
* bitmap pool的复用
* onTrimMemory触发下的内存管理
* listview快速滑动下，bitmap的管理

##### 图片请求的三级缓存

glide请求的执行主流程可以参考[流程](https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/Glide%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md)

我们从SingleRequest的onSizeReady回调方法开始分析

{% highlight java%}
public void onSizeReady(int width, int height) {
    ......
    status = Status.RUNNING;

    float sizeMultiplier = requestOptions.getSizeMultiplier();
    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);
    
    //开始用引擎
    loadStatus = engine.load()
    ....


  public synchronized <R> LoadStatus load() {
    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;

    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
        resourceClass, transcodeClass, options);

    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      return null;
    }

    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    ....
{% endhighlight %}

`loadFromActiveResources`指的是从当前正在展示的EngineResource中获取，它是一个弱引用的hashmap。

`loadFromCache`指的是从内存中获取，是一个LruLinkedHashMap结构。

ActiveResources和cache间会相互传递。ActiveResources被释放后会存到cache里，cache命中后会删除自身缓存然后
存储到ActiveResources里。

那么上述代码就解决了glide缓存中的前两级缓存。

* 弱引用实现的活动资源缓存
* lru实现的内存缓存

接下来看怎么实现的文件缓存。

看一下DecodeJob的runWapped方法
{% highlight java %}
private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        currentGenerator = getNextGenerator();
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException("Unrecognized run reason: " + runReason);
    }
  }

private Stage getNextStage(Stage current) {
    switch (current) {
      case INITIALIZE:
        return diskCacheStrategy.decodeCachedResource()
            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
      case RESOURCE_CACHE:
        return diskCacheStrategy.decodeCachedData()
            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
      case DATA_CACHE:
        // Skip loading from source if the user opted to only retrieve the resource from cache.
        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
      case SOURCE:
      case FINISHED:
        return Stage.FINISHED;
      default:
        throw new IllegalArgumentException("Unrecognized stage: " + current);
    }
  }

public enum DataSource {
  /**
   * Indicates data was probably retrieved locally from the device, although it may have been
   * obtained through a content provider that may have obtained the data from a remote source.
   */
  LOCAL,
  /**
   * Indicates data was retrieved from a remote source other than the device.
   */
  REMOTE,
  /**
   * Indicates data was retrieved unmodified from the on device cache.
   */
  DATA_DISK_CACHE,
  /**
   * Indicates data was retrieved from modified content in the on device cache.
   */
  RESOURCE_DISK_CACHE,
  /**
   * Indicates data was retrieved from the in memory cache.
   */
  MEMORY_CACHE,
}

{% endhighlight %}

注意磁盘缓存有两个概念，Data和Resource。前者缓存源数据，后者缓存解码和转换后的数据。
glide运用了策略模式，在DiskCacheStrategy类里有五种硬盘缓存策略实现。

那么至此，glide的三级缓存就讲完了。


##### bitmap pool的复用
具体看Downsampler的decodeFromWrappedStreams方法

{% highligh java %}
...
if (expectedWidth > 0 && expectedHeight > 0) {
        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
      }
...

private static void setInBitmap(
      BitmapFactory.Options options, BitmapPool bitmapPool, int width, int height) {
    ...
    options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig);
  }
{% endhighlight%}

bitmap pool的实现是软引用。在应用内存不够的时候，会对其进行回收


