---
layout: post
title:  "OkHttp请求拦截器链分析"
date:   2023-12-13 10:48:00 +0800
tags:   开源库
description:
---

前言
-------------
网上的博客分析okhttp3的拦截器都是单独一个个列出来谈

我觉得这样不妥。因为拦截器的调用是一个递归式的U型图调用。我们从http的请求报文角度来分析，
各个系统拦截器做了哪些工作。

上篇文章以及分析了okhttp的系统架构。okhttp的拦截器是典型的责任链设计模式，那么你还记得有哪些系统的拦截器吗？

直接贴出代码吧

```java
    ...
    interceptors.addAll(client.interceptors());
    interceptors.add(new RetryAndFollowUpInterceptor(client));
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    interceptors.add(new CacheInterceptor(client.internalCache()));
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
      interceptors.addAll(client.networkInterceptors());
    }
    interceptors.add(new CallServerInterceptor(forWebSocket));
    ...
```

http请求拦截是从上至下，响应则是从下至上。那就开始各个分析吧！

##### RetryAndFollowUpInterceptor

```java

  @Override public Response intercept(Chain chain) throws IOException {
    Request request = chain.request();
    RealInterceptorChain realChain = (RealInterceptorChain) chain;
    Transmitter transmitter = realChain.transmitter();

    int followUpCount = 0;
    Response priorResponse = null;
    while (true) {
      transmitter.prepareToConnect(request);

      if (transmitter.isCanceled()) {
        throw new IOException("Canceled");
      }

      Response response;
      boolean success = false;
      try {
        response = realChain.proceed(request, transmitter, null);
        ......
```
关注的是请求部分，所以只看`realChain.proceed`以上的代码。有效代码只有`transmitter.prepareToConnect(request)`

```java
  public void prepareToConnect(Request request) {
    if (this.request != null) {
      if (sameConnection(this.request.url(), request.url()) && exchangeFinder.hasRouteToTry()) {
        return; // Already ready.
      }
      if (exchange != null) throw new IllegalStateException();

      if (exchangeFinder != null) {
        maybeReleaseConnection(null, true);
        exchangeFinder = null;
      }
    }

    this.request = request;
    this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),
        call, eventListener);
  }

```
代码只是给`Transmitter`类的成员request和exchangeFinder赋值。那么看来RetryAndFollowUpInterceptor拦截器
似乎在请求阶段，没有做任何的工作。







