---
layout: post
title:  "阅读《Android开发精要》的笔记"
date:   2017-12-19 15:38:00 +0800
categories: 学习
tags:   android
description: 看着很爽，其实提升有限，还是要从源码了解细节。记录下好的代码模板
---
阅读这本书的本意，是为阅读Android源码而做准备。阅读后发现两者并没有什么关系，这本书是一本工具书啦，有些不错的代码模板记录一下....

### 邮件(P128)
在Android原生的邮件应用中，当用户修改了邮件内容并主动退出编辑页面之前，系统会弹出对话框询问用户是否需要保存编辑过的邮件；而如果是系统回收组件导致的被动退出，则不会突兀的弹出对话框来干扰用户：
{% highlight java %}
// 记录是否需要保存邮件草稿
boolean needSaveDraft = true;
...
protected void onSaveInstanceState(Bundle outState) {
  super.onSaveInstanceState();
  // 先保存邮件修改状态，用于重新启动时恢复该信息
  outState.putBoolean("NEED_SAVE_DRAFT", needSaveDraft);
  // 将是否需要保存设置为false,表示在被动退出时无需保存草稿
  needSaveDraft = false;
}

protected void onPause() {
  // 如果用户修改了邮件草稿，并且不是被动退出，则询问用户是否保存
  if (needSaveDraft) {
    ShowAskSaveDraftDialog();
  }
}
{% endhighlight %}

当Activity.onSaveInstanceState函数调用完成后，存储着状态信息的outState对象中的*数据就由系统进程代为保管*，不管该应用进程是否被系统回收，这些数据都不会丢失。

###  避免线程泄露(P131)
{% highlight java %}
private static final String WORKER_KEY = "thread_id";
private Thread worker;

protected void onCreate(Bundle saveInstanceState) {
  if (saveInstanceState != null) {
    final long threadId = saveInstanceState.getLong(WORKER_KEY);
    worker = findThredById(threadId);
  }

  if (thread == null) {
    worker = createNewWorker();
    worker.start();
  }
}

protected void onSaveInstanceState(Bundle outState) {
  if (worker != null) {
    outState.putLong(worker.getId());
  }
}

protected void onDestroy() {
  if (worker != null) {
    worker.interrupt();
    worker = null;
  }
}
{% endhighlight %}


### 关于Service.onStartCommand函数(P135)
从Android 2.0开始，系统提供了Service.onStartCommand函数,取代原有的Service.onStart函数。onStartCommand函数中增加了返回值和控制参数，用于指定后台服务组件的运行方式，其中**最重要的返回值**有三个。
* Service.START_STICKY
* Service.START_NOT_STICKY
* Service.START_REDELIVER_INTENT
